

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>idtrack._harmonize_features &mdash; idtrack 0.0.4 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/custom_settings.css?v=15bcc2cf" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=8c5712d9"></script>
      <script src="../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            idtrack
              <img src="../../_static/logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference.html">Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributor Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../authors.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../code_of_conduct.html">Contributor Covenant Code of Conduct</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">idtrack</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">idtrack._harmonize_features</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for idtrack._harmonize_features</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">gc</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pickle</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">cached_property</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">anndata</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ad</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tqdm</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.sparse</span><span class="w"> </span><span class="kn">import</span> <span class="n">csr_matrix</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">idtrack</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">idtrack</span><span class="w"> </span><span class="kn">import</span> <span class="n">DB</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">idtrack._db</span><span class="w"> </span><span class="kn">import</span> <span class="n">MISSING_VALUES</span>


<div class="viewcode-block" id="HarmonizeFeatures">
<a class="viewcode-back" href="../../reference.html#idtrack._harmonize_features.HarmonizeFeatures">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">HarmonizeFeatures</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Harmonize gene/feature identifiers across multiple single-cell expression datasets.</span>

<span class="sd">    This manager streamlines the otherwise error-prone task of bringing heterogeneous gene identifiers</span>
<span class="sd">    (Ensembl IDs, gene symbols, etc.) into a single, version-controlled namespace before integrated</span>
<span class="sd">    downstream analysis.  Under the hood it leverages :py:class:`idtrack.api.API` to resolve identifier</span>
<span class="sd">    mappings through a pre-computed Ensembl graph, handles one-to-many and one-to-zero conversions, logs</span>
<span class="sd">    any ambiguous or inconsistent matches, and finally produces harmonised</span>
<span class="sd">    :py:class:`anndata.AnnData` objects ready for comparative or joint analysis.</span>

<span class="sd">    The public workflow is intentionally simple:</span>

<span class="sd">    * :py:meth:`feature_harmonizer` — convert a single dataset and return the filtered ``AnnData`` plus</span>
<span class="sd">      before/after feature counts.</span>
<span class="sd">    * :py:meth:`unify_multiple_anndatas` — apply harmonisation across *all* supplied datasets and return</span>
<span class="sd">      an integrated object.</span>
<span class="sd">    * :py:meth:`get_idtrack_matchings_for_all_datasets` — inspect the raw IDTrack matchings used.</span>

<span class="sd">    Instances keep several diagnostic attributes (e.g. ``removed_conversion_failed_identifiers``,</span>
<span class="sd">    ``multiple_ensembl_dict``) so that users can audit every decision that removed or altered a feature.</span>

<span class="sd">    Args:</span>
<span class="sd">        project_name (str): Human-readable label used in log messages and derived output file names.</span>
<span class="sd">        data_h5ad_dict (dict[str, str]): Mapping *dataset_alias → absolute .h5ad path* of the source</span>
<span class="sd">            single-cell expression matrices.</span>
<span class="sd">        project_local_repository (str): Writable directory where harmonised outputs, logs, and temporary</span>
<span class="sd">            artefacts will be stored.</span>
<span class="sd">        idtrack_local_repository (str): Local clone or cache directory understood by</span>
<span class="sd">            :py:class:`idtrack.api.API`; used to read the pre-built identifier graph.</span>
<span class="sd">        target_ensembl_release (int): Ensembl release that all identifiers will be converted *to*.  Must</span>
<span class="sd">            be ≤ *graph_last_ensembl_release*.</span>
<span class="sd">        final_database (str): Canonical namespace kept after conversion (e.g. ``&quot;HGNC Symbol&quot;``).</span>
<span class="sd">            Defaults to ``&quot;HGNC Symbol&quot;``.</span>
<span class="sd">        organism_name (str): Ensembl-style organism short name (e.g. ``&quot;homo_sapiens&quot;``).</span>
<span class="sd">            Defaults to ``&quot;homo_sapiens&quot;``.</span>
<span class="sd">        graph_last_ensembl_release (int): Highest release present in the on-disk IDTrack graph.</span>
<span class="sd">            Defaults to ``114``.</span>
<span class="sd">        verbose_level (Literal[0, 1, 2]): Logging verbosity; 0 = errors only, 1 = warnings, 2 =</span>
<span class="sd">            info.  Defaults to ``2``.</span>
<span class="sd">        debugging_variables (bool): Retain heavy intermediate structures for post-mortem</span>
<span class="sd">            inspection.  Defaults to ``False``.</span>
<span class="sd">        converted_id_column (str): Column name used to store converted identifiers inside the</span>
<span class="sd">            resulting ``AnnData.var`` DataFrame.  Defaults to ``&quot;converted_id&quot;``.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        idt (idtrack.api.API): Lazily initialised IDTrack interface used for all identifier look-ups.</span>
<span class="sd">        multiple_ensembl_dict (dict[str, list[str]]): Map of collapsed IDs to *all* Ensembl IDs that were</span>
<span class="sd">            originally associated with the same target identifier.</span>
<span class="sd">        removed_conversion_failed_identifiers (dict[str, set[str]]): Features that failed conversion and</span>
<span class="sd">            were dropped from each dataset.</span>
<span class="sd">        kept_conversion_failed_identifiers (dict[str, set[str]]): Non-convertible features kept because</span>
<span class="sd">            they were consistently non-convertible across *all* datasets.</span>
<span class="sd">        removed_inconsistent_identifier_matching (dict[str, set[str]]): Features whose mappings disagreed</span>
<span class="sd">            between datasets and were therefore removed for consistency.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nonmatching_but_consistent_suffix</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">project_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">data_h5ad_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>  <span class="c1"># custom dataset name to dataset absolute path</span>
        <span class="n">project_local_repository</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">idtrack_local_repository</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">target_ensembl_release</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">final_database</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;HGNC Symbol&quot;</span><span class="p">,</span>
        <span class="n">organism_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;homo_sapiens&quot;</span><span class="p">,</span>
        <span class="n">graph_last_ensembl_release</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">114</span><span class="p">,</span>
        <span class="n">verbose_level</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">debugging_variables</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">converted_id_column</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;converted_id&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiate the harmoniser and perform lightweight validation.</span>

<span class="sd">        The constructor merely *prepares* the harmonisation context: it validates input paths, configures</span>
<span class="sd">        logging, and primes IDTrack.  Heavy work—graph initialisation, identifier matching, gene-symbol</span>
<span class="sd">        resolution—happens lazily when the first harmonisation method is called.</span>

<span class="sd">        Args:</span>
<span class="sd">            project_name (str): See :py:meth:`HarmonizeFeatures`.</span>
<span class="sd">            data_h5ad_dict (dict[str, str]): See :py:meth:`HarmonizeFeatures`.</span>
<span class="sd">            project_local_repository (str): See :py:meth:`HarmonizeFeatures`.</span>
<span class="sd">            idtrack_local_repository (str): See :py:meth:`HarmonizeFeatures`.</span>
<span class="sd">            target_ensembl_release (int): See :py:meth:`HarmonizeFeatures`.</span>
<span class="sd">            final_database (str): See :py:meth:`HarmonizeFeatures`.</span>
<span class="sd">            organism_name (str): See :py:meth:`HarmonizeFeatures`.</span>
<span class="sd">            graph_last_ensembl_release (int): See :py:meth:`HarmonizeFeatures`.</span>
<span class="sd">            verbose_level (Literal[0, 1, 2]): See :py:meth:`HarmonizeFeatures`.</span>
<span class="sd">            debugging_variables (bool): See :py:meth:`HarmonizeFeatures`.</span>
<span class="sd">            converted_id_column (str): See :py:meth:`HarmonizeFeatures`.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If *verbose_level* is not 0, 1, or 2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">project_name</span> <span class="o">=</span> <span class="n">project_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">project_local_repository</span> <span class="o">=</span> <span class="n">project_local_repository</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_h5ad_dict</span> <span class="o">=</span> <span class="n">data_h5ad_dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">converted_id_column</span> <span class="o">=</span> <span class="n">converted_id_column</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idtrack_local_repository</span> <span class="o">=</span> <span class="n">idtrack_local_repository</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_ensembl_release</span> <span class="o">=</span> <span class="n">target_ensembl_release</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph_last_ensembl_release</span> <span class="o">=</span> <span class="n">graph_last_ensembl_release</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final_database</span> <span class="o">=</span> <span class="n">final_database</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">organism_name</span> <span class="o">=</span> <span class="n">organism_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_datasets</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_h5ad_dict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debugging_variables</span> <span class="o">=</span> <span class="n">debugging_variables</span>

        <span class="k">if</span> <span class="n">verbose_level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logging</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">ERROR</span>
        <span class="k">elif</span> <span class="n">verbose_level</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">_logging</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">WARNING</span>
        <span class="k">elif</span> <span class="n">verbose_level</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logging</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span>
        <span class="k">elif</span> <span class="n">verbose_level</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">_logging</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose_level</span> <span class="o">=</span> <span class="n">verbose_level</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">idt</span> <span class="o">=</span> <span class="n">idtrack</span><span class="o">.</span><span class="n">API</span><span class="p">(</span><span class="n">local_repository</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">idtrack_local_repository</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;harmonize_features&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idt</span><span class="o">.</span><span class="n">configure_logger</span><span class="p">(</span><span class="n">_logging</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idt_initialized</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dict_n_to_1</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">multiple_ensembl_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="c1"># Important dictionaries for debugging:</span>

        <span class="c1"># If there is n-to-1 matching in a database and if one of them is query=matching, keep it and remove others</span>
        <span class="c1"># for a given group (n), below shows the chosen id (due to its identical as explained), the group</span>
        <span class="c1"># and the datasets that has this group</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dict_n_to_1_with_query</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="c1"># this dictionary is ideal to find out the removed ids</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dict_n_to_1_with_query_reverse</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="c1"># this is a dictary showing group-to-dataset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dict_n_to_1_without_query</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="c1"># also:</span>
        <span class="c1"># cached_property: self.dict_1_to_not_1</span>

        <span class="c1"># to include into integrated anndata object.</span>

        <span class="c1"># sometimes, final database (e.g. HGNC) id is associated with multiple ensembl ids, the algorithm chooses</span>
        <span class="c1"># one of them and creates a list. here you can find the actual possible ensembl ids.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">multiple_ensembl_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="c1"># removed ids from the anndata by `harmonizer` method. the list and the in which datasets it is deleted is kept.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">removed_conversion_failed_identifiers</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="c1"># these ids could be removed but kept as they are consistent across all provided datasets.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kept_conversion_failed_identifiers</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="c1"># inconsistent matching</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">removed_inconsistent_identifier_matching</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize</span><span class="p">()</span>

<div class="viewcode-block" id="HarmonizeFeatures._initialize">
<a class="viewcode-back" href="../../reference.html#idtrack._harmonize_features.HarmonizeFeatures._initialize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Populate diagnostic structures for failed or ambiguous identifier conversions.</span>

<span class="sd">        Called once by :py:meth:`HarmonizeFeatures.__init__`, this routine scans every input dataset and</span>
<span class="sd">        updates several reporting attributes (for example :py:attr:`removed_conversion_failed_identifiers`</span>
<span class="sd">        or :py:attr:`removed_inconsistent_identifier_matching`).  It also derives</span>
<span class="sd">        :py:attr:`multiple_ensembl_dict`, a reverse map of ambiguous *Ensembl ID → source identifiers*,</span>
<span class="sd">        enabling downstream inspection of one-to-many relationships.</span>

<span class="sd">        Returns ``None``: All results are stored on *self* for later inspection.</span>

<span class="sd">        Internally the method:</span>

<span class="sd">        1. Extracts raw feature identifiers from each :py:class:`anndata.AnnData` file.</span>
<span class="sd">        2. Classifies identifiers into failure or inconsistency categories.</span>
<span class="sd">        3. Records per-dataset membership via :py:meth:`reporter_dict_creator`.</span>
<span class="sd">        4. Builds the ``multiple_ensembl_list`` used by</span>
<span class="sd">           :py:meth:`HarmonizeFeatures.create_multiple_ensembl_dict`.</span>
<span class="sd">        5. Touches :py:meth:`datataset_conversion_dataframe_issues` so the cached-property is built</span>
<span class="sd">           eagerly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">dataset_name</span><span class="p">,</span> <span class="n">dataset_path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_h5ad_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">gene_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_source_identifiers_from_anndata</span><span class="p">(</span><span class="n">dataset_path</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">reporter_dict_creator</span><span class="p">(</span>
                <span class="n">dataset_name</span><span class="o">=</span><span class="n">dataset_name</span><span class="p">,</span>
                <span class="n">the_dict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">removed_conversion_failed_identifiers</span><span class="p">,</span>
                <span class="n">the_set</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="n">gene_list</span><span class="p">)</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">conversion_failed_identifiers</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">reporter_dict_creator</span><span class="p">(</span>
                <span class="n">dataset_name</span><span class="o">=</span><span class="n">dataset_name</span><span class="p">,</span>
                <span class="n">the_dict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">kept_conversion_failed_identifiers</span><span class="p">,</span>
                <span class="n">the_set</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="n">gene_list</span><span class="p">)</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">conversion_failed_but_consistent_identifiers</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">reporter_dict_creator</span><span class="p">(</span>
                <span class="n">dataset_name</span><span class="o">=</span><span class="n">dataset_name</span><span class="p">,</span>
                <span class="n">the_dict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">removed_inconsistent_identifier_matching</span><span class="p">,</span>
                <span class="n">the_set</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="n">gene_list</span><span class="p">)</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">datataset_conversion_dataframe_issues</span><span class="p">[</span><span class="s2">&quot;gene_names_inconsistency&quot;</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">the_id</span> <span class="ow">in</span> <span class="n">gene_list</span><span class="p">:</span>
                <span class="n">conversion</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unified_matching_dict</span><span class="p">[</span><span class="n">the_id</span><span class="p">][</span><span class="s2">&quot;matching&quot;</span><span class="p">][</span><span class="s2">&quot;last_node&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">the_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">conversion_failed_but_consistent_identifiers</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">multiple_ensembl_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">conversion</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">multiple_ensembl_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_multiple_ensembl_dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datataset_conversion_dataframe_issues</span></div>


<div class="viewcode-block" id="HarmonizeFeatures._initialize_idt">
<a class="viewcode-back" href="../../reference.html#idtrack._harmonize_features.HarmonizeFeatures._initialize_idt">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_initialize_idt</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiate the IDTrack interface on first use.</span>

<span class="sd">        The public API defers expensive graph loading until it is actually required.  This helper therefore</span>
<span class="sd">        checks whether :py:attr:`idt` is ``None`` and, if so, loads the on-disk identifier graph described by</span>
<span class="sd">        *idtrack_local_repository* and *graph_last_ensembl_release*, then configures release filters so that</span>
<span class="sd">        subsequent look-ups always target *target_ensembl_release*.  Re-invocations are no-ops.</span>

<span class="sd">        Returns ``None``: The :py:attr:`idt` attribute is populated and ready for queries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">idt_initialized</span><span class="p">:</span>
            <span class="n">organism_formal_name</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">idt</span><span class="o">.</span><span class="n">get_ensembl_organism</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">organism_name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">idt</span><span class="o">.</span><span class="n">initialize_graph</span><span class="p">(</span>
                <span class="n">organism_name</span><span class="o">=</span><span class="n">organism_formal_name</span><span class="p">,</span> <span class="n">last_ensembl_release</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">graph_last_ensembl_release</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">idt</span><span class="o">.</span><span class="n">calculate_graph_caches</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">idt_initialized</span> <span class="o">=</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="HarmonizeFeatures.create_multiple_ensembl_dict">
<a class="viewcode-back" href="../../reference.html#idtrack._harmonize_features.HarmonizeFeatures.create_multiple_ensembl_dict">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_multiple_ensembl_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reverse map ambiguous Ensembl target IDs to their originating source identifiers.</span>

<span class="sd">        During scanning, :py:meth:`_initialize` collects every *(source_id, target_ensembl_id)* pair that</span>
<span class="sd">        falls outside the *consistent one-to-one* category into ``multiple_ensembl_list``.  This helper</span>
<span class="sd">        consolidates that list into a dictionary keyed by ``target_ensembl_id`` with a **sorted list** of</span>
<span class="sd">        associated ``source_id`` values, allowing auditors to quickly discover all inputs that collapsed</span>
<span class="sd">        onto the same Ensembl record.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict[str, list[str]]: ``{target_ensembl_id: [source_id₁, source_id₂, …]}`` with duplicates</span>
<span class="sd">            removed and values sorted alphanumerically.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">multiple_ensembl_list</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">i</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">m</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
                    <span class="n">r</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="n">r</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span></div>


<div class="viewcode-block" id="HarmonizeFeatures.reporter_dict_creator_helper_reason_finder">
<a class="viewcode-back" href="../../reference.html#idtrack._harmonize_features.HarmonizeFeatures.reporter_dict_creator_helper_reason_finder">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reporter_dict_creator_helper_reason_finder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">the_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Infer why a particular identifier failed or produced a non-one-to-one conversion.</span>

<span class="sd">        The algorithm inspects :py:attr:`unified_matching_dict` and categorises *the_id* into one or more</span>
<span class="sd">        mutually non-exclusive reasons:</span>

<span class="sd">        * ``&quot;n-to-1&quot;``   — The identifier was part of an *n → 1* collapse within *at least one* dataset.</span>
<span class="sd">        * ``&quot;1-to-0&quot;``   — No target identifier was returned (conversion failure).</span>
<span class="sd">        * ``&quot;1-to-n&quot;``   — The conversion yielded multiple targets (ambiguous mapping).</span>

<span class="sd">        The final label is a single string where multiple reasons are concatenated with underscores, e.g.</span>
<span class="sd">        ``&quot;1-to-0_1-to-n&quot;``.</span>

<span class="sd">        Args:</span>
<span class="sd">            the_id (str): Source identifier whose conversion outcome needs explanation.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: Underscore-delimited reason string describing the failure or ambiguity class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reason</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">matching</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unified_matching_dict</span><span class="p">[</span><span class="n">the_id</span><span class="p">]</span>
        <span class="n">len_targets</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matching</span><span class="p">[</span><span class="s2">&quot;matching&quot;</span><span class="p">][</span><span class="s2">&quot;target_id&quot;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">the_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict_n_to_1</span><span class="p">:</span>  <span class="c1"># in one of the datasets during the integration, this ID was a part of n-to-1.</span>
            <span class="n">reason</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;n-to-1&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">len_targets</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">reason</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;1-to-0&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">len_targets</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">reason</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;1-to-n&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">reason</span><span class="p">)</span></div>


<div class="viewcode-block" id="HarmonizeFeatures.reporter_dict_creator">
<a class="viewcode-back" href="../../reference.html#idtrack._harmonize_features.HarmonizeFeatures.reporter_dict_creator">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reporter_dict_creator</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">the_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">],</span>
        <span class="n">the_set</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">dataset_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update or create per-identifier diagnostic entries for a single dataset.</span>

<span class="sd">        Each identifier in *the_set* is ensured to exist as a key inside *the_dict*.  The entry&#39;s</span>
<span class="sd">        ``&quot;reason&quot;`` field is generated exactly once using</span>
<span class="sd">        :py:meth:`reporter_dict_creator_helper_reason_finder`; its ``&quot;datasets_containing&quot;`` list is then</span>
<span class="sd">        appended with *dataset_name*.  This allows quick aggregation of “where did this problematic</span>
<span class="sd">        identifier occur?” across all datasets.</span>

<span class="sd">        Returns ``None``: *the_dict* is modified in-place.</span>

<span class="sd">        Args:</span>
<span class="sd">            the_dict (dict[str, dict]): Target dictionary that stores diagnostic metadata.  Keys are</span>
<span class="sd">                source identifiers; values have keys ``&quot;reason&quot;`` (``str``) and</span>
<span class="sd">                ``&quot;datasets_containing&quot;`` (``list[str]``).</span>
<span class="sd">            the_set (set[str]): Identifiers that belong to the diagnostic category represented by</span>
<span class="sd">                *the_dict*.</span>
<span class="sd">            dataset_name (str): Human-readable alias of the dataset currently being processed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">the_set</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">the_dict</span><span class="p">:</span>
                <span class="n">the_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;reason&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">reporter_dict_creator_helper_reason_finder</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="s2">&quot;datasets_containing&quot;</span><span class="p">:</span> <span class="p">[]}</span>
            <span class="n">the_dict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;datasets_containing&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dataset_name</span><span class="p">)</span></div>


    <span class="nd">@cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">datataset_conversion_dataframe_issues</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Aggregate conversion failures and ambiguities into a tidy diagnostic table.</span>

<span class="sd">        The cached DataFrame has one row per *source identifier* encountered across **all** datasets and</span>
<span class="sd">        the following columns:</span>

<span class="sd">        * ``dataset``                — Dataset alias that triggered the row (duplicates possible).</span>
<span class="sd">        * ``reason``                 — Underscore-delimited label from</span>
<span class="sd">          :py:meth:`reporter_dict_creator_helper_reason_finder`.</span>
<span class="sd">        * ``target_identifier``      — The resolved identifier or ``NaN`` if conversion failed.</span>
<span class="sd">        * ``was_removed`` (bool)     — Whether the feature was ultimately dropped from the dataset.</span>

<span class="sd">        This compact view is ideal for spreadsheet export or in-notebook inspection because it condenses</span>
<span class="sd">        the richer nested structures stored on the class into a flat, analysis-friendly format.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pandas.DataFrame: Combined diagnostic table sorted lexicographically by *dataset* and *reason*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gene_list</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unified_matching_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">conversion_failed_identifiers</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_dataset_conversion_dataframe</span><span class="p">(</span><span class="n">gene_list</span><span class="o">=</span><span class="n">gene_list</span><span class="p">,</span> <span class="n">initialization_run</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># In Shiddar and Wang in HLCA datasets contains FAM231C, and FAM231B. Very weird genes, IDTrack fails:</span>
        <span class="c1"># ENSG00000268674.2	FAM231C	FAM231C</span>
        <span class="c1"># ENSG00000268674.2	FAM231B	FAM231B</span>
        <span class="c1"># Report and remove from all conversion lists.</span>
        <span class="n">dfa</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;ensembl_gene&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_database</span><span class="p">],</span> <span class="n">keep</span><span class="o">=</span><span class="s2">&quot;first&quot;</span><span class="p">)</span>
        <span class="n">_gene_names_inconsistency</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dfa</span><span class="p">[</span><span class="n">dfa</span><span class="p">[</span><span class="s2">&quot;ensembl_gene&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">)][</span><span class="bp">self</span><span class="o">.</span><span class="n">final_database</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
        <span class="n">gene_names_inconsistency</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">final_database</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">_gene_names_inconsistency</span><span class="p">)][</span><span class="s2">&quot;Query ID&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>

        <span class="n">final_database_chosen_single_ensembl_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">final_final_database_gene_name</span><span class="p">,</span> <span class="n">df_subset</span> <span class="ow">in</span> <span class="n">dfa</span><span class="p">[</span><span class="n">dfa</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">final_database</span><span class="p">]</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">)]</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">final_database</span>
        <span class="p">):</span>
            <span class="c1"># Due to the path, idtrack may choose different ensembl_gene</span>
            <span class="c1"># for corresponding final_database (e.g. HGNC). Here, make a rule for each final_database id.</span>
            <span class="c1"># You can see all possible ensembl ids in</span>
            <span class="n">chosen_ensembl_id</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">df_subset</span><span class="p">[</span><span class="s2">&quot;ensembl_gene&quot;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># choose first one</span>
            <span class="n">final_database_chosen_single_ensembl_dict</span><span class="p">[</span><span class="n">final_final_database_gene_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">chosen_ensembl_id</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;gene_names_inconsistency&quot;</span><span class="p">:</span> <span class="n">gene_names_inconsistency</span><span class="p">,</span>
            <span class="s2">&quot;final_database_chosen_single_ensembl_dict&quot;</span><span class="p">:</span> <span class="n">final_database_chosen_single_ensembl_dict</span><span class="p">,</span>
        <span class="p">}</span>

<div class="viewcode-block" id="HarmonizeFeatures.create_dataset_conversion_dataframe">
<a class="viewcode-back" href="../../reference.html#idtrack._harmonize_features.HarmonizeFeatures.create_dataset_conversion_dataframe">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_dataset_conversion_dataframe</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">gene_list</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">],</span> <span class="n">initialization_run</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build a two-column mapping table for a single dataset&#39;s feature identifiers.</span>

<span class="sd">        The routine transforms every source identifier in *gene_list* into the target namespace defined by</span>
<span class="sd">        ``self.final_database`` and Ensembl gene IDs.  The resulting convertible subset is written into a</span>
<span class="sd">        new :py:class:`pandas.DataFrame` with three columns—``&quot;ensembl_gene&quot;``, ``self.final_database``,</span>
<span class="sd">        and ``&quot;Query ID&quot;``—while problematic identifiers are annotated or filtered according to the rules</span>
<span class="sd">        established during :py:meth:`_initialize`.</span>

<span class="sd">        When called by :py:meth:`_initialize` (*initialization_run* ``True``), the method writes provisional</span>
<span class="sd">        mappings without inspecting post-initialisation overrides.  In subsequent calls</span>
<span class="sd">        (*initialization_run* ``False``) it resolves single-Ensembl ambiguities via</span>
<span class="sd">        ``self.datataset_conversion_dataframe_issues[&quot;final_database_chosen_single_ensembl_dict&quot;]`` to</span>
<span class="sd">        guarantee a one-to-one relation between indices and feature rows.</span>

<span class="sd">        Args:</span>
<span class="sd">            gene_list (Union[list[str], pd.Index]): Ordered collection of source identifiers to convert for</span>
<span class="sd">                the current dataset.</span>
<span class="sd">            initialization_run (bool): ``True`` if invoked from :py:meth:`_initialize`; disables the</span>
<span class="sd">                single-Ensembl disambiguation step applied in later passes.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pandas.DataFrame: Mapping table ready to become ``adata.var``.  Columns are</span>
<span class="sd">            ``&quot;ensembl_gene&quot;``, ``self.final_database``, and the original ``&quot;Query ID&quot;`` for traceability.</span>

<span class="sd">        Raises:</span>
<span class="sd">            AssertionError: If diagnostic sets such as :py:attr:`conversion_failed_identifiers` were not</span>
<span class="sd">                populated—indicating an incorrect call order—or if unexpected duplicate target IDs remain</span>
<span class="sd">                after processing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conversion_failed_identifiers</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conversion_failed_but_consistent_identifiers</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Possible function call order issue!&quot;</span><span class="p">)</span>

        <span class="n">new_var_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">the_id</span> <span class="ow">in</span> <span class="n">gene_list</span><span class="p">:</span>
            <span class="n">conversion</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unified_matching_dict</span><span class="p">[</span><span class="n">the_id</span><span class="p">][</span><span class="s2">&quot;matching&quot;</span><span class="p">][</span><span class="s2">&quot;last_node&quot;</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">the_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">conversion_failed_but_consistent_identifiers</span><span class="p">:</span>
                <span class="n">modified_id</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">the_id</span><span class="si">}{</span><span class="n">HarmonizeFeatures</span><span class="o">.</span><span class="n">nonmatching_but_consistent_suffix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">the_id</span><span class="p">)</span>
                <span class="n">new_var_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">modified_id</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">the_id</span><span class="p">])</span>

            <span class="c1"># 1-to-n&#39;s and 1-to-0s are either removed or kept as consistent ones.</span>
            <span class="c1"># if there is multiple ensembl id matching, then len(conversion) != 1.</span>
            <span class="c1"># it keeps the first one for now, the possible lists are saved self.multiple_ensembl_list in `initialize` method</span>

            <span class="k">elif</span> <span class="n">initialization_run</span><span class="p">:</span>
                <span class="n">new_var_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">conversion</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="p">[</span><span class="n">the_id</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">conversion</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;len(c) != 2&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">datataset_conversion_dataframe_issues</span><span class="p">[</span><span class="s2">&quot;final_database_chosen_single_ensembl_dict&quot;</span><span class="p">]:</span>
                    <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datataset_conversion_dataframe_issues</span><span class="p">[</span><span class="s2">&quot;final_database_chosen_single_ensembl_dict&quot;</span><span class="p">][</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

                <span class="n">new_var_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="p">[</span><span class="n">the_id</span><span class="p">])</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">new_var_list</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;ensembl_gene&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_database</span><span class="p">,</span> <span class="s2">&quot;Query ID&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="HarmonizeFeatures.feature_harmonizer">
<a class="viewcode-back" href="../../reference.html#idtrack._harmonize_features.HarmonizeFeatures.feature_harmonizer">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">feature_harmonizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert one dataset&#39;s feature space into the unified target namespace.</span>

<span class="sd">        This convenience wrapper reads a single ``.h5ad`` file, removes identifiers deemed unusable during</span>
<span class="sd">        :py:meth:`_initialize`, applies the conversion mapping from</span>
<span class="sd">        :py:meth:`create_dataset_conversion_dataframe`, and returns a *new* :py:class:`anndata.AnnData`</span>
<span class="sd">        object with harmonised features.  The function is intentionally side-effect-free: it never alters</span>
<span class="sd">        the source file, and large temporary matrices are deleted immediately to minimise memory usage.</span>

<span class="sd">        Args:</span>
<span class="sd">            dataset_name (str): Key from :py:attr:`data_h5ad_dict` identifying which dataset to load and</span>
<span class="sd">                harmonise.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple:</span>
<span class="sd">                * **resulting_adata** (:py:class:`anndata.AnnData`) - Dataset whose ``var`` now contains</span>
<span class="sd">                  ``&quot;ensembl_gene&quot;`` as index and ``self.final_database`` as a column.</span>
<span class="sd">                * **t0** (int) - Number of features *before* filtering and harmonisation.</span>
<span class="sd">                * **t1** (int) - Number of features *after* the procedure (i.e., retained in</span>
<span class="sd">                  *resulting_adata*).</span>

<span class="sd">        Raises:</span>
<span class="sd">            AssertionError: If duplicate Ensembl or target-database IDs slip past the conversion checks,</span>
<span class="sd">                which would break one-to-one mapping assumptions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">adata</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">read_h5ad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_h5ad_dict</span><span class="p">[</span><span class="n">dataset_name</span><span class="p">])</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">n_vars</span>
        <span class="n">remove_bool</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conversion_failed_identifiers</span><span class="p">)</span>
            <span class="o">|</span> <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datataset_conversion_dataframe_issues</span><span class="p">[</span><span class="s2">&quot;gene_names_inconsistency&quot;</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="n">adata</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[:,</span> <span class="n">remove_bool</span><span class="p">]</span>

        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_dataset_conversion_dataframe</span><span class="p">(</span><span class="n">gene_list</span><span class="o">=</span><span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">initialization_run</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">bool_remove</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ensembl_gene&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">final_database</span><span class="p">]</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">bool_remove</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Unexpected duplicated entry!&quot;</span><span class="p">)</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;ensembl_gene&quot;</span><span class="p">)</span>
        <span class="n">resulting_adata</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">,</span> <span class="n">var</span><span class="o">=</span><span class="n">df</span><span class="p">)</span>  <span class="c1"># dtype=adata.X.dtype,</span>

        <span class="n">t1</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">n_vars</span>
        <span class="k">del</span> <span class="n">adata</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">resulting_adata</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span></div>


    <span class="nd">@cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dict_1_to_not_1</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Collect identifiers involved in one-to-many or one-to-zero conversions.</span>

<span class="sd">        This helper scans :py:attr:`unified_matching_dict` and extracts every *source identifier* whose</span>
<span class="sd">        conversion to the target namespace is **not** a strict one-to-one mapping.  Two situations are</span>
<span class="sd">        considered problematic:</span>

<span class="sd">        * **1 → 0 (conversion failure)** — no target identifier could be resolved.</span>
<span class="sd">        * **1 → n (ambiguous hit)** — multiple targets share the best score, preventing an unambiguous choice.</span>

<span class="sd">        The resulting dictionary is later consumed by :py:meth:`reporter_dict_creator` to populate the</span>
<span class="sd">        diagnostic attributes exposed to users and by</span>
<span class="sd">        :py:meth:`create_dataset_conversion_dataframe` to decide which features should be dropped or</span>
<span class="sd">        flagged in each :py:class:`anndata.AnnData` object.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict[str, set[str]]: ``{problem_class: {source_id₁, source_id₂, …}}`` where *problem_class* is</span>
<span class="sd">                either ``&quot;1-to-0&quot;`` or ``&quot;1-to-n&quot;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">query</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unified_matching_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="s2">&quot;matching&quot;</span><span class="p">][</span><span class="s2">&quot;target_id&quot;</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">query</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="s2">&quot;datasets_containing&quot;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">conversion_failed_identifiers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return identifiers that could not be converted in at least one dataset.</span>

<span class="sd">        The property wraps :py:meth:`dict_1_to_not_1` and filters its ``&quot;1-to-0&quot;`` category so that</span>
<span class="sd">        downstream code can quickly query *irrecoverable* failures without iterating over the entire</span>
<span class="sd">        diagnostic structure.</span>

<span class="sd">        Returns:</span>
<span class="sd">            set[str]: Todo.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">query</span><span class="p">,</span> <span class="n">datasets_containing</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict_1_to_not_1</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># for 1-to-n and 1-to-0, if it is not shared across all the datasets, add remove list.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">datasets_containing</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_datasets</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">query</span><span class="p">,</span> <span class="n">datasets_containing_2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict_n_to_1</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># for one gene in n (among n-to-1), if it is not shared across all the datasets, add remove list.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">datasets_containing_2</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_datasets</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">conversion_failed_but_consistent_identifiers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Identify non-convertible identifiers that are consistently absent across *all* datasets.</span>

<span class="sd">        An identifier that fails conversion in *every* dataset can be retained (or at least logged once)</span>
<span class="sd">        without jeopardising dataset comparability.  This property computes the set intersection of</span>
<span class="sd">        :py:attr:`conversion_failed_identifiers` across datasets and makes the result available for</span>
<span class="sd">        selective retention or downstream visualisation.</span>

<span class="sd">        Returns:</span>
<span class="sd">            set[str]: Identifiers that were never convertible but appeared in every dataset examined.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_result1</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict_n_to_1</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">conversion_failed_identifiers</span><span class="p">}</span>
        <span class="n">_result2</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict_1_to_not_1</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">conversion_failed_identifiers</span><span class="p">}</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">_result1</span><span class="p">,</span> <span class="n">_result2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">unified_matching_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Expose the full source-to-target identifier mapping produced by IDTrack.</span>

<span class="sd">        The dictionary is created during :py:meth:`_initialize` when the IDTrack graph is first queried.</span>
<span class="sd">        Keys are *source identifiers* (as found in input files); values are **all** candidate target IDs</span>
<span class="sd">        returned by the graph query, ordered by decreasing score.  A value may therefore be</span>

<span class="sd">        * a single-element list (unambiguous one-to-one),</span>
<span class="sd">        * a multi-element list (ambiguous one-to-n), or</span>
<span class="sd">        * an empty list (1-to-0 conversion failure).</span>

<span class="sd">        Public access to this attribute enables advanced users to perform their own diagnostics or to</span>
<span class="sd">        reproduce the algorithm&#39;s decisions outside the class.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict[str, list[str]]: Mapping ``{source_id: [target_id₁, target_id₂, …]}`` in the order</span>
<span class="sd">                delivered by the IDTrack query.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matching_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_idtrack_matchings_for_all_datasets</span><span class="p">()</span>
        <span class="n">unified_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">dataset_name</span><span class="p">,</span> <span class="n">matching</span> <span class="ow">in</span> <span class="n">matching_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">matching</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">m</span><span class="p">[</span><span class="s2">&quot;query_id&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unified_dict</span><span class="p">:</span>
                    <span class="n">unified_dict</span><span class="p">[</span><span class="n">m</span><span class="p">[</span><span class="s2">&quot;query_id&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;matching&quot;</span><span class="p">:</span> <span class="n">m</span><span class="p">,</span> <span class="s2">&quot;datasets_containing&quot;</span><span class="p">:</span> <span class="p">[]}</span>
                <span class="n">unified_dict</span><span class="p">[</span><span class="n">m</span><span class="p">[</span><span class="s2">&quot;query_id&quot;</span><span class="p">]][</span><span class="s2">&quot;datasets_containing&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dataset_name</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">unified_dict</span>

<div class="viewcode-block" id="HarmonizeFeatures.get_idtrack_matchings_for_all_datasets">
<a class="viewcode-back" href="../../reference.html#idtrack._harmonize_features.HarmonizeFeatures.get_idtrack_matchings_for_all_datasets">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_idtrack_matchings_for_all_datasets</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return raw ID-Track matchings for every dataset in the project.</span>

<span class="sd">        This helper exposes the unfiltered mapping tables produced by ID-Track so that users can inspect</span>
<span class="sd">        exactly how each *source identifier* was converted (or failed to convert) in every individual</span>
<span class="sd">        dataset.  Internally it triggers :py:meth:`run_idtrack_for_single_dataset` for any dataset that</span>
<span class="sd">        has not yet been processed, caches the resulting tables in memory, and then assembles a</span>
<span class="sd">        ``{dataset_name: dataframe}`` dictionary whose keys align one-to-one with :py:data:`data_h5ad_dict`.</span>

<span class="sd">        Each returned :py:class:`pandas.DataFrame` includes at least the following columns:</span>
<span class="sd">        ``source_id``, ``target_id``, ``conversion_status``, ``reason``, and any custom</span>
<span class="sd">        metadata injected by :py:class:`idtrack.api.API`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict[str, pandas.DataFrame]: Mapping of dataset alias to its full, row-level ID-Track</span>
<span class="sd">            matching table.  The dictionary order follows the insertion order of</span>
<span class="sd">            :py:data:`data_h5ad_dict`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result_dataset</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">dataset_name</span><span class="p">,</span> <span class="n">dataset_path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_h5ad_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">dataset_pickle</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">project_local_repository</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;idtrack_result_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">project_name</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">dataset_name</span><span class="si">}</span><span class="s2">.pickle&quot;</span>
            <span class="p">)</span>

            <span class="n">switch_inconsistency</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">dataset_pickle</span><span class="p">)</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">access</span><span class="p">(</span><span class="n">dataset_pickle</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">R_OK</span><span class="p">):</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">dataset_pickle</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
                    <span class="n">matching_list</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span>
                <span class="n">_saved_id_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">i</span><span class="p">[</span><span class="s2">&quot;query_id&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">matching_list</span><span class="p">])</span>
                <span class="n">_dataset_id_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extract_source_identifiers_from_anndata</span><span class="p">(</span><span class="n">dataset_path</span><span class="o">=</span><span class="n">dataset_path</span><span class="p">))</span>

                <span class="c1"># if the id lists are different than the provided one.</span>
                <span class="n">switch_inconsistency</span> <span class="o">=</span> <span class="n">_saved_id_list</span> <span class="o">!=</span> <span class="n">_dataset_id_list</span>

            <span class="k">if</span> <span class="n">switch_inconsistency</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">switch_inconsistency</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose_level</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Pickle not found: `</span><span class="si">{</span><span class="n">dataset_name</span><span class="si">}</span><span class="s2">`. Calculating IDTrack matchings.&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">switch_inconsistency</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose_level</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                        <span class="s2">&quot;Inconsistent IDs with pickle object and the &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;dataset: `</span><span class="si">{</span><span class="n">dataset_name</span><span class="si">}</span><span class="s2">`. Calculating IDTrack matchings.&quot;</span>
                    <span class="p">)</span>
                <span class="n">matching_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_idtrack_for_single_dataset</span><span class="p">(</span><span class="n">dataset_name</span><span class="p">,</span> <span class="n">dataset_path</span><span class="p">)</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">dataset_pickle</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
                    <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">matching_list</span><span class="p">,</span> <span class="n">handle</span><span class="p">)</span>

            <span class="n">result_dataset</span><span class="p">[</span><span class="n">dataset_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">matching_list</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose_level</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">binned_conversions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">idt</span><span class="o">.</span><span class="n">classify_multiple_conversion</span><span class="p">(</span><span class="n">matching_list</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dataset_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">idt</span><span class="o">.</span><span class="n">print_binned_conversion</span><span class="p">(</span><span class="n">binned_conversions</span><span class="p">)</span>

            <span class="c1"># Do not allow n_to_1 within a certain dataset.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_to_1_within_individual_dataset</span><span class="p">(</span><span class="n">dataset_name</span><span class="o">=</span><span class="n">dataset_name</span><span class="p">,</span> <span class="n">dataset_matching_list</span><span class="o">=</span><span class="n">matching_list</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result_dataset</span></div>


<div class="viewcode-block" id="HarmonizeFeatures.extract_source_identifiers_from_anndata">
<a class="viewcode-back" href="../../reference.html#idtrack._harmonize_features.HarmonizeFeatures.extract_source_identifiers_from_anndata">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">extract_source_identifiers_from_anndata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load an ``.h5ad`` file and harvest the raw feature identifiers.</span>

<span class="sd">        To prepare inputs for ID-Track, this routine opens the single-cell expression matrix at</span>
<span class="sd">        *dataset_path*, reads the ``.var`` DataFrame, and extracts either the ``&quot;gene_id&quot;`` field (if</span>
<span class="sd">        present) or the index itself as the *source identifier*.  Identifiers are returned in file order</span>
<span class="sd">        so that downstream procedures can preserve the original feature ordering when reconstructing</span>
<span class="sd">        matrices.</span>

<span class="sd">        Args:</span>
<span class="sd">            dataset_path (str): Absolute or project-relative path to an ``.h5ad`` file containing a valid</span>
<span class="sd">                :py:class:`anndata.AnnData` object.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]: Ordered list of identifier strings exactly as they appear in the source file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">adata</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">read_h5ad</span><span class="p">(</span><span class="n">dataset_path</span><span class="p">,</span> <span class="n">backed</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">adata</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="HarmonizeFeatures.run_idtrack_for_single_dataset">
<a class="viewcode-back" href="../../reference.html#idtrack._harmonize_features.HarmonizeFeatures.run_idtrack_for_single_dataset">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">run_idtrack_for_single_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dataset_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert identifiers for one dataset and cache the raw ID-Track output.</span>

<span class="sd">        Given a dataset alias and its on-disk location, this method:</span>

<span class="sd">        1. Calls :py:meth:`extract_source_identifiers_from_anndata` to obtain the feature list.</span>
<span class="sd">        2. Feeds those identifiers to :py:class:`idtrack.api.API` and collects the per-feature match</span>
<span class="sd">           results.</span>
<span class="sd">        3. Stores the resulting :py:class:`pandas.DataFrame` inside the</span>
<span class="sd">           :py:attr:`_idtrack_matchings_per_dataset` cache so repeated calls are O(1).</span>
<span class="sd">        4. Updates :py:attr:`unified_matching_dict` so that cross-dataset diagnostics remain consistent.</span>

<span class="sd">        Users rarely call this directly—:py:meth:`get_idtrack_matchings_for_all_datasets` handles the</span>
<span class="sd">        orchestration—but it remains public for advanced, dataset-by-dataset debugging.</span>

<span class="sd">        Args:</span>
<span class="sd">            dataset_name (str): Human-friendly alias used as the key inside diagnostic dictionaries.</span>
<span class="sd">            dataset_path (str): Absolute or project-relative ``.h5ad`` path passed straight to</span>
<span class="sd">                :py:meth:`extract_source_identifiers_from_anndata`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pandas.DataFrame: Full ID-Track matching table for *dataset_name* with columns</span>
<span class="sd">                ``source_id``, ``target_id``, ``conversion_status``, and any extra metadata returned by the API.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_idt</span><span class="p">()</span>
        <span class="n">gene_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_source_identifiers_from_anndata</span><span class="p">(</span><span class="n">dataset_path</span><span class="p">)</span>

        <span class="n">matching_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">idt</span><span class="o">.</span><span class="n">convert_identifier_multiple</span><span class="p">(</span>
            <span class="n">gene_list</span><span class="p">,</span>
            <span class="n">final_database</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">final_database</span><span class="p">,</span>
            <span class="n">to_release</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">target_ensembl_release</span><span class="p">,</span>
            <span class="n">pbar_prefix</span><span class="o">=</span><span class="n">dataset_name</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose_level</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">matching_list</span></div>


<div class="viewcode-block" id="HarmonizeFeatures.n_to_1_within_individual_dataset">
<a class="viewcode-back" href="../../reference.html#idtrack._harmonize_features.HarmonizeFeatures.n_to_1_within_individual_dataset">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">n_to_1_within_individual_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dataset_matching_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Detect n-to-1 collapses inside one dataset and populate diagnostic caches.</span>

<span class="sd">        In the ID-Track context *n-to-1* means **several source identifiers** (``query_id``) converging on the</span>
<span class="sd">        **same target identifier** (``matched_id``).  Such collapses are problematic because they merge</span>
<span class="sd">        distinct features when building the harmonised expression matrix.  This helper inspects the raw</span>
<span class="sd">        matching rows for a single dataset, discovers all many-to-one events (including those that passed</span>
<span class="sd">        through the *alternative target database*), and records the results in a family of per-project</span>
<span class="sd">        dictionaries so that later stages—merging, filtering, and reporting—can make informed decisions.</span>

<span class="sd">        The routine never returns a value; instead it mutates the following public attributes:</span>

<span class="sd">        * :py:attr:`dict_n_to_1` - ``{matched_id: [dataset₁, dataset₂, …]}`` listing every dataset where the</span>
<span class="sd">          collapse occurred.</span>
<span class="sd">        * :py:attr:`dict_n_to_1_with_query` - ``{matched_id: {(query_id₁,…): [dataset]}}`` for cases where the</span>
<span class="sd">          ``matched_id`` also appears in the collapsing query set.</span>
<span class="sd">        * :py:attr:`dict_n_to_1_with_query_reverse` - ``{query_id: {matched_id: [dataset]}}`` for a</span>
<span class="sd">          query-centric view.</span>
<span class="sd">        * :py:attr:`dict_n_to_1_without_query` - collapses where the target never appears in its own query set.</span>

<span class="sd">        Returns ``None``: All information is stored on the instance for subsequent pipeline stages.</span>

<span class="sd">        Args:</span>
<span class="sd">            dataset_name (str): Human-readable alias used throughout the project for *this* dataset.</span>
<span class="sd">            dataset_matching_list (list[dict]): Raw per-feature matchings returned by</span>
<span class="sd">                :py:class:`idtrack.api.API`.  Each dictionary must provide at least the keys</span>
<span class="sd">                ``&quot;query_id&quot;``, ``&quot;last_node&quot;``, and ``&quot;final_database&quot;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reverse_dict_target</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">reverse_dict_alternative_target</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">matching_entry</span> <span class="ow">in</span> <span class="n">dataset_matching_list</span><span class="p">:</span>

            <span class="c1"># to capture matching without alternative target database.</span>
            <span class="c1"># note that final database is `None` for 1-to-0, `ensembl_gene` for alternative target database.</span>

            <span class="n">query_id</span> <span class="o">=</span> <span class="n">matching_entry</span><span class="p">[</span><span class="s2">&quot;query_id&quot;</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">matching_entry</span><span class="p">[</span><span class="s2">&quot;final_database&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_database</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">matching_entry</span><span class="p">[</span><span class="s2">&quot;last_node&quot;</span><span class="p">]:</span>  <span class="c1"># for loop if it is 1-to-n</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">reverse_dict_target</span><span class="p">:</span>
                        <span class="n">reverse_dict_target</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">reverse_dict_target</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">query_id</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">matching_entry</span><span class="p">[</span><span class="s2">&quot;final_database&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;ensembl_gene&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">matching_entry</span><span class="p">[</span><span class="s2">&quot;last_node&quot;</span><span class="p">]:</span>  <span class="c1"># for loop if it is 1-to-n</span>

                    <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">reverse_dict_alternative_target</span><span class="p">:</span>
                        <span class="n">reverse_dict_alternative_target</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">reverse_dict_alternative_target</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">query_id</span><span class="p">)</span>

        <span class="c1"># simply get the ids that has 1-to-n in reverse orientation, so get n-to-1</span>

        <span class="n">set_n_to_1_in_dataset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">the_dict_of_interest</span> <span class="ow">in</span> <span class="p">[</span><span class="n">reverse_dict_target</span><span class="p">,</span> <span class="n">reverse_dict_alternative_target</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">matched_id</span><span class="p">,</span> <span class="n">query_id_list</span> <span class="ow">in</span> <span class="n">the_dict_of_interest</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">query_id_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">query_id</span> <span class="ow">in</span> <span class="n">query_id_list</span><span class="p">:</span>

                        <span class="c1"># if there is query and mathed id are the same, exlude this query id from the n-to-1 set.</span>
                        <span class="c1"># basically assign it to be the true matching of the conversion for integration tasks</span>
                        <span class="k">if</span> <span class="n">query_id</span> <span class="o">!=</span> <span class="n">matched_id</span><span class="p">:</span>
                            <span class="c1"># and matching is 1:1. note that if matching is actually 1-to-n,</span>
                            <span class="c1"># it is resolved by other parts of the code.</span>
                            <span class="n">set_n_to_1_in_dataset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">query_id</span><span class="p">)</span>

                    <span class="c1"># For debugging and reporting</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debugging_variables</span><span class="p">:</span>
                        <span class="n">query_id_list_tuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">query_id_list</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">matched_id</span> <span class="ow">in</span> <span class="n">query_id_list_tuple</span><span class="p">:</span>

                            <span class="k">if</span> <span class="n">matched_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict_n_to_1_with_query</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">dict_n_to_1_with_query</span><span class="p">[</span><span class="n">matched_id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                            <span class="k">if</span> <span class="n">query_id_list_tuple</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict_n_to_1_with_query</span><span class="p">[</span><span class="n">matched_id</span><span class="p">]:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">dict_n_to_1_with_query</span><span class="p">[</span><span class="n">matched_id</span><span class="p">][</span><span class="n">query_id_list_tuple</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">dict_n_to_1_with_query</span><span class="p">[</span><span class="n">matched_id</span><span class="p">][</span><span class="n">query_id_list_tuple</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dataset_name</span><span class="p">)</span>

                            <span class="k">for</span> <span class="n">query_id</span> <span class="ow">in</span> <span class="n">query_id_list_tuple</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">query_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict_n_to_1_with_query_reverse</span><span class="p">:</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">dict_n_to_1_with_query_reverse</span><span class="p">[</span><span class="n">query_id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                                <span class="k">if</span> <span class="n">matched_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict_n_to_1_with_query_reverse</span><span class="p">[</span><span class="n">query_id</span><span class="p">]:</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">dict_n_to_1_with_query_reverse</span><span class="p">[</span><span class="n">query_id</span><span class="p">][</span><span class="n">matched_id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">dict_n_to_1_with_query_reverse</span><span class="p">[</span><span class="n">query_id</span><span class="p">][</span><span class="n">matched_id</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dataset_name</span><span class="p">)</span>

                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">query_id_list_tuple</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict_n_to_1_without_query</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">dict_n_to_1_without_query</span><span class="p">[</span><span class="n">query_id_list_tuple</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">dict_n_to_1_without_query</span><span class="p">[</span><span class="n">query_id_list_tuple</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dataset_name</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">nto1</span> <span class="ow">in</span> <span class="n">set_n_to_1_in_dataset</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nto1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict_n_to_1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dict_n_to_1</span><span class="p">[</span><span class="n">nto1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dict_n_to_1</span><span class="p">[</span><span class="n">nto1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dataset_name</span><span class="p">)</span></div>


<div class="viewcode-block" id="HarmonizeFeatures.unify_multiple_anndatas">
<a class="viewcode-back" href="../../reference.html#idtrack._harmonize_features.HarmonizeFeatures.unify_multiple_anndatas">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">unify_multiple_anndatas</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;union&quot;</span><span class="p">,</span> <span class="s2">&quot;intersect&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;union&quot;</span><span class="p">,</span>
        <span class="n">obs_columns_to_keep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">numeric_var_columns</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">numeric_obs_columns</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># for hdca it is {&quot;age&quot;}</span>
        <span class="n">handle_anndata_key</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;handle_anndata&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Merge several study-specific :py:class:`anndata.AnnData` objects into a single, consolidated dataset.</span>

<span class="sd">        This helper finalises the *feature-harmonisation* workflow.  Earlier stages ensure that every source study</span>
<span class="sd">        expresses its features (e.g. genes or proteins) in a consistent identifier namespace and that per-cell</span>
<span class="sd">        metadata follow a shared schema.  *unify_multiple_anndatas* takes those already normalised objects—stored in</span>
<span class="sd">        :py:attr:`~HarmonizeFeatures.data_h5ad_dict`—and fuses them into one coherent :py:class:`~anndata.AnnData`</span>
<span class="sd">        ready for joint analysis (dimensionality reduction, batch correction, integrated clustering, etc.).</span>

<span class="sd">        Two strategies govern how the function reconciles mismatched feature sets:</span>

<span class="sd">        * ``&quot;union&quot;`` (default) preserves the superset of all identifiers.  If a particular study lacks a feature,</span>
<span class="sd">            its expression values are imputed as exact zeros.  This choice maximises information retention at the</span>
<span class="sd">            cost of a sparse matrix with assay-dependent missingness.</span>

<span class="sd">        * ``&quot;intersect&quot;`` retains only the identifiers present in *every* study, implicitly discarding features</span>
<span class="sd">            unique to a subset.  This yields a denser matrix that is easier to factorise but sacrifices potentially</span>
<span class="sd">            informative study-specific biology.</span>

<span class="sd">        Beyond concatenating the main :py:attr:`~anndata.AnnData.X` matrices, the routine also harmonises associated</span>
<span class="sd">        annotations:</span>

<span class="sd">        * **.var (feature annotations)**</span>
<span class="sd">            All columns are outer-joined across studies.  Non-shared categorical values are unioned; numeric columns</span>
<span class="sd">            specified in *numeric_var_columns* are cast to floating point and NaNs inserted where data are missing.</span>
<span class="sd">            In *union* mode an additional boolean ``&quot;intersection&quot;`` column flags whether a feature survived the</span>
<span class="sd">            *intersect* filter, enabling fast subsetting later.</span>

<span class="sd">        * **.obs (cell annotations)**</span>
<span class="sd">            Each original column is kept if its name appears in *obs_columns_to_keep* **or** if it exists in every</span>
<span class="sd">            study.  Missing columns are created and populated with ``pandas.NA``.  Columns listed in</span>
<span class="sd">            *numeric_obs_columns* are coerced to ``float64``.  A new column named *handle_anndata_key* stores the</span>
<span class="sd">            handle (dictionary key) that identifies the originating study, making it trivial to stratify analyses.</span>

<span class="sd">        * **.layers, .obsp, .varp, .uns**</span>
<span class="sd">            This method uses :py:meth:`anndata.AnnData.concat` for this.</span>

<span class="sd">        The implementation is mindful of scalability: concatenation leverages SciPy CSR/CSC sparse formats,</span>
<span class="sd">        avoiding densification, and streaming allocation prevents double memory use for extremely large datasets.</span>

<span class="sd">        Args:</span>
<span class="sd">            mode (Literal[&quot;union&quot;, &quot;intersect&quot;]): Strategy for reconciling discordant feature sets.  ``&quot;union&quot;``</span>
<span class="sd">                keeps every identifier observed across studies (padding absent entries with zeros); ``&quot;intersect&quot;``</span>
<span class="sd">                restricts the result to identifiers common to *all* studies.  Defaults to ``&quot;union&quot;``.</span>
<span class="sd">            obs_columns_to_keep (list[str] | None): Names of per-cell metadata columns that must survive the merge</span>
<span class="sd">                even if they appear in only a subset of studies (e.g. *cell_type*, *donor_age*).  When a column is</span>
<span class="sd">                missing from a particular study, it is inserted and filled with ``pandas.NA``.  Provide an empty</span>
<span class="sd">                list to allow the routine to decide purely by intersection; ``None`` means “no user preference”.</span>
<span class="sd">            numeric_var_columns (set[str] | None): Columns in ``.var`` that should retain numeric dtype.  The</span>
<span class="sd">                function validates that each specified column can be losslessly converted to floating point;</span>
<span class="sd">                otherwise it raises :py:class:`ValueError`.  Non-listed columns default to ``category`` dtype to</span>
<span class="sd">                conserve memory.  If ``None`` an empty set is assumed.</span>
<span class="sd">            numeric_obs_columns (set[str] | None): Analogous to *numeric_var_columns* but applied to ``.obs``.</span>
<span class="sd">                Conversions are performed *after* the table has been unioned, ensuring consistent dtype across the</span>
<span class="sd">                final concatenated frame.  If ``None`` an empty set is assumed.</span>
<span class="sd">            handle_anndata_key (str): Name of the column inserted into ``.obs`` that records the dictionary key of</span>
<span class="sd">                the source study.  This provenance tag facilitates stratified visualisation (e.g. UMAP coloured by</span>
<span class="sd">                batch) and downstream batch-correction utilities that expect a “batch” column.  Defaults to</span>
<span class="sd">                ``&quot;handle_anndata&quot;``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            anndata.AnnData: A fully merged expression matrix whose ``.X`` contains either the union or intersection</span>
<span class="sd">                of all study features.  Index ordering follows the order in which studies were supplied, ensuring</span>
<span class="sd">                deterministic output for reproducible pipelines.  The result inherits sparse/dense representation from</span>
<span class="sd">                the first study unless *mode* forces feature padding, in which case CSR/CSC is chosen automatically to</span>
<span class="sd">                keep memory use in check.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If *mode* is not ``&quot;union&quot;`` or ``&quot;intersect&quot;``; if any column listed in</span>
<span class="sd">                *numeric_var_columns* or *numeric_obs_columns* fails numeric coercion; or if feature identifiers</span>
<span class="sd">                clash across studies after harmonisation (e.g. two studies mapping different genes to the same ID).</span>
<span class="sd">            AssertionError: If duplicate cell or feature indices are detected post-merge, a condition that would</span>
<span class="sd">                break many Scanpy workflows and indicates upstream validation errors.</span>

<span class="sd">        Notes:</span>
<span class="sd">            *Performance considerations*</span>
<span class="sd">            The operation is CPU-bound when aligning large sparse matrices.  For</span>
<span class="sd">            datasets exceeding ~1 million cells, empirical benchmarks show that running on Python 3.11 with MKL</span>
<span class="sd">            yields a 2-3x speed-up over Python 3.8 due to better sparse BLAS threading.  Provide pre-compressed</span>
<span class="sd">            datasets (``hdf5``, ``zarr``) to further lower I/O overhead.</span>

<span class="sd">            *Thread safety*</span>
<span class="sd">            The method is re-entrant but **not** thread-safe because it mutates the source</span>
<span class="sd">            :py:class:`~anndata.AnnData` objects in-place to reduce copying.  Invoke one instance per process or</span>
<span class="sd">            deep-copy the inputs beforehand if concurrent harmonisation is required.</span>

<span class="sd">            *Extensibility*</span>
<span class="sd">            Sub-classes may override private hooks</span>
<span class="sd">            :py:meth:`_before_concat`, :py:meth:`_after_concat`, and :py:meth:`_merge_uns` to refine behaviour without</span>
<span class="sd">            re-implementing the full algorithm.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">numeric_obs_columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">numeric_obs_columns</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">numeric_var_columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">numeric_var_columns</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">obs_columns_to_keep</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">obs_columns_to_keep</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="c1"># numeric_obs_columns: set[str] = numeric_obs_columns if numeric_obs_columns is not None else set()</span>
        <span class="c1"># numeric_var_columns: set[str] = numeric_var_columns if numeric_var_columns is not None else set()</span>
        <span class="c1"># obs_columns_to_keep: list[str] = obs_columns_to_keep if obs_columns_to_keep is not None else list()</span>

        <span class="n">_adata_var</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="n">_adata_obs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="n">handle_anndata_key</span><span class="p">]</span> <span class="o">+</span> <span class="n">obs_columns_to_keep</span><span class="p">)</span>
        <span class="n">_adata_var</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">_adata_var</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>  <span class="c1"># to prevent ImplicitModificationWarning later on</span>
        <span class="n">_adata_obs</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">_adata_obs</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>  <span class="c1"># to prevent ImplicitModificationWarning later on</span>
        <span class="n">_adata_x</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
        <span class="n">adata</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">_adata_x</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">_adata_obs</span><span class="p">,</span> <span class="n">var</span><span class="o">=</span><span class="n">_adata_var</span><span class="p">)</span>

        <span class="n">remove_var_columns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">pbar</span> <span class="o">=</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_h5ad_dict</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">140</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pbar</span><span class="p">):</span>
            <span class="n">adata_study</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_harmonizer</span><span class="p">(</span><span class="n">dataset_name</span><span class="o">=</span><span class="n">handle</span><span class="p">)</span>
            <span class="n">adata_study</span><span class="o">.</span><span class="n">obs_names</span> <span class="o">=</span> <span class="n">adata_study</span><span class="o">.</span><span class="n">obs_names</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>  <span class="c1"># to prevent ImplicitModificationWarning later on</span>
            <span class="n">adata_study</span><span class="o">.</span><span class="n">var_names</span> <span class="o">=</span> <span class="n">adata_study</span><span class="o">.</span><span class="n">var_names</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>  <span class="c1"># to prevent ImplicitModificationWarning later on</span>
            <span class="n">adata_study</span><span class="o">.</span><span class="n">obs</span> <span class="o">=</span> <span class="n">adata_study</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">obs_columns_to_keep</span><span class="p">]</span>

            <span class="n">pbar</span><span class="o">.</span><span class="n">set_postfix</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s2">&quot;dataset&quot;</span><span class="p">:</span> <span class="n">handle</span><span class="p">,</span>
                    <span class="s2">&quot;study_var&quot;</span><span class="p">:</span> <span class="n">adata_study</span><span class="o">.</span><span class="n">n_vars</span><span class="p">,</span>
                    <span class="s2">&quot;union_var&quot;</span><span class="p">:</span> <span class="n">adata</span><span class="o">.</span><span class="n">n_vars</span><span class="p">,</span>
                    <span class="s2">&quot;dbh&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">t0</span> <span class="o">-</span> <span class="n">t1</span><span class="p">),</span>  <span class="c1"># deleted by harmonizer</span>
                <span class="p">}</span>
            <span class="p">)</span>
            <span class="n">pbar</span><span class="o">.</span><span class="n">refresh</span><span class="p">()</span>
            <span class="c1"># adata_study.obs[&quot;sample_ID&quot;] = adata_study.obs[&quot;sample_ID&quot;].astype(str)  used in hdca?</span>
            <span class="n">adata_study</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">handle_anndata_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">adata_study</span><span class="o">.</span><span class="n">n_obs</span><span class="p">,</span> <span class="n">handle</span><span class="p">)</span>

            <span class="n">adata_study</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s2">&quot;unified_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">handle</span><span class="si">}</span><span class="s2">_&quot;</span> <span class="o">+</span> <span class="n">adata_study</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
            <span class="n">adata_study</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;unified_index&quot;</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">final_databases_tested</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;HGNC Symbol&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_database</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">final_databases_tested</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Final database other than following databases is not tested:  </span><span class="si">{</span><span class="n">final_databases_tested</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="n">adata_study</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Query ID&quot;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">new_final_database_var_column</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">converted_id_column</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">handle</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">adata_study</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span>
                <span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">final_database</span><span class="p">:</span> <span class="n">new_final_database_var_column</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;raise&quot;</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;union&quot;</span> <span class="ow">or</span> <span class="n">ind</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">var_map</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                    <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">,</span>
                    <span class="n">adata_study</span><span class="o">.</span><span class="n">var</span><span class="p">,</span>
                    <span class="n">how</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">,</span>
                    <span class="n">left_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="n">adata</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
                    <span class="n">adatas</span><span class="o">=</span><span class="p">[</span><span class="n">adata</span><span class="p">,</span> <span class="n">adata_study</span><span class="p">],</span>
                    <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">,</span>
                    <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s2">&quot;union&quot;</span><span class="p">:</span>
                    <span class="n">remove_var_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_final_database_var_column</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;intersect&quot;</span><span class="p">:</span>
                <span class="n">var_map</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                    <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">,</span>
                    <span class="n">adata_study</span><span class="o">.</span><span class="n">var</span><span class="p">,</span>
                    <span class="n">how</span><span class="o">=</span><span class="s2">&quot;inner&quot;</span><span class="p">,</span>  <span class="c1"># changed from &quot;outer&quot; to &quot;inner&quot;</span>
                    <span class="n">left_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="n">adata</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
                    <span class="n">adatas</span><span class="o">=</span><span class="p">[</span><span class="n">adata</span><span class="p">,</span> <span class="n">adata_study</span><span class="p">],</span>
                    <span class="n">join</span><span class="o">=</span><span class="s2">&quot;inner&quot;</span><span class="p">,</span>  <span class="c1"># changed from &quot;outer&quot; to &quot;inner&quot;</span>
                <span class="p">)</span>
                <span class="n">remove_var_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_final_database_var_column</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span>

            <span class="c1"># create a mask to array and put it in `uns`, to specify which</span>
            <span class="c1"># are added `0`s because of the `idtrack` process.</span>
            <span class="c1"># not needed: look at the adata.var</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">var_map</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">duplicated</span><span class="p">()):</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;np.any(var_map.index.duplicated())&quot;</span><span class="p">)</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">var</span> <span class="o">=</span> <span class="n">var_map</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="p">]</span>

            <span class="k">del</span> <span class="n">adata_study</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>

        <span class="c1"># Check unified gene naming</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">index</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;len(set(adata.var.index)) != len(adata.var.index)&quot;</span><span class="p">)</span>
        <span class="n">gene_name_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">var</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">converted_id_column</span><span class="si">}</span><span class="s2">_&quot;</span><span class="p">)]</span>
        <span class="n">gene_name_columns</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="n">gene_name_columns</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">gene_names_unified</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">gene_names_inconsistency</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ind_i</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gene_name_columns</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="o">~</span><span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">gene_names_inconsistency</span><span class="p">[</span><span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">ind_i</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">converted_id_column</span><span class="si">}</span><span class="s2">_&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">i</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                <span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gene_names_unified</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gene_names_inconsistency</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;len(gene_names_inconsistency) != 0&quot;</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
            <span class="n">adata</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[:,</span> <span class="o">~</span><span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">gene_names_inconsistency</span><span class="o">.</span><span class="n">keys</span><span class="p">())]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">converted_id_column</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;self.converted_id_column in adata.var.columns&quot;</span><span class="p">)</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">converted_id_column</span><span class="p">]</span> <span class="o">=</span> <span class="n">gene_names_unified</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">converted_id_column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;self.converted_id_column not in adata.var.columns&quot;</span><span class="p">)</span>

        <span class="c1"># For `intersect` mode, all these columns are gonna be the same, so delete.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">remove_var_columns</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">var</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">remove_var_columns</span><span class="p">)</span>

        <span class="c1"># Return</span>
        <span class="k">for</span> <span class="n">numeric_obs_column</span> <span class="ow">in</span> <span class="n">numeric_obs_columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">numeric_obs_column</span><span class="p">],</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;coerce&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Non-numeric value in adata.obs at </span><span class="si">{</span><span class="n">numeric_obs_column</span><span class="si">!r}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">numeric_obs_column</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">numeric_obs_column</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">numeric_obs_columns</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># Convert to string, remove categories</span>
            <span class="c1"># Replace None or &#39;nan&#39; values with &#39;NA&#39;</span>
            <span class="c1"># Convert back to categorical</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">column</span><span class="p">]</span>
                <span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>  <span class="c1"># ensure string</span>
                <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">MISSING_VALUES</span><span class="p">,</span> <span class="n">DB</span><span class="o">.</span><span class="n">placeholder_na</span><span class="p">)</span>  <span class="c1"># no inplace</span>
                <span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;category&quot;</span><span class="p">)</span>  <span class="c1"># recast</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">numeric_var_column</span> <span class="ow">in</span> <span class="n">numeric_var_columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="n">numeric_var_column</span><span class="p">],</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;coerce&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Non-numeric value in adata.var at </span><span class="si">{</span><span class="n">numeric_var_column</span><span class="si">!r}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="n">numeric_var_column</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="n">numeric_var_column</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">numeric_var_columns</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="n">column</span><span class="p">]</span>
                <span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
                <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">MISSING_VALUES</span><span class="p">,</span> <span class="n">DB</span><span class="o">.</span><span class="n">placeholder_na</span><span class="p">)</span>  <span class="c1"># no inplace</span>
                <span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;category&quot;</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;union&quot;</span><span class="p">:</span>
            <span class="n">intersect_column_name</span> <span class="o">=</span> <span class="s2">&quot;intersection&quot;</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="n">intersect_column_name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_intersection_column_values</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="n">intersect_column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="n">intersect_column_name</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">adata</span></div>


<div class="viewcode-block" id="HarmonizeFeatures.create_intersection_column_values">
<a class="viewcode-back" href="../../reference.html#idtrack._harmonize_features.HarmonizeFeatures.create_intersection_column_values">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_intersection_column_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">adata_var</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Flag features present in **every** study after harmonisation.</span>

<span class="sd">        The merged ``.var`` table produced by :py:meth:`unify_multiple_anndatas` contains one gene-symbol column per</span>
<span class="sd">        study, each named ``f&quot;{self.converted_id_column}_{handle}&quot;`` where *handle* is the dictionary key that</span>
<span class="sd">        identifies the originating dataset.  A cell in one of those columns holds the *gene symbol* originally</span>
<span class="sd">        reported by the study, or :py:data:`idtrack._db.DB.placeholder_na` if the gene was absent or could not be</span>
<span class="sd">        mapped to the target namespace.</span>

<span class="sd">        This helper collapses the per-study presence/absence information into a single boolean *intersection* flag,</span>
<span class="sd">        later exposed to users as ``adata.var[&quot;intersection&quot;]``.  A value of ``1`` indicates that the feature</span>
<span class="sd">        survived the *intersect* filter—i.e., it has a valid symbol in **all** studies—whereas ``0`` marks features</span>
<span class="sd">        missing from at least one dataset.  The resulting NumPy vector is inserted by the caller; this routine is</span>
<span class="sd">        intentionally pure and side-effect free.</span>

<span class="sd">        Args:</span>
<span class="sd">            adata_var (pandas.DataFrame): The ``.var`` table of the *already concatenated* :py:class:`anndata.AnnData`</span>
<span class="sd">                object.  It must contain one or more columns whose names start with</span>
<span class="sd">                ``f&quot;{self.converted_id_column}_&quot;``; each such column is assumed to encode the gene symbol for a</span>
<span class="sd">                particular study.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: A 1-D array of ``int`` (values ``0`` or ``1``) with ``len(adata_var)`` elements.  The</span>
<span class="sd">            *i*-th entry equals ``1`` if the *i*-th feature is present (non-</span>
<span class="sd">            :py:data:`idtrack._db.DB.placeholder_na`) in **every** per-study symbol column; otherwise it is ``0``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gene_name_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">adata_var</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">converted_id_column</span><span class="si">}</span><span class="s2">_&quot;</span><span class="p">)]</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">adata_var</span><span class="p">[</span><span class="n">gene_name_columns</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span> <span class="o">!=</span> <span class="n">DB</span><span class="o">.</span><span class="n">placeholder_na</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">gene_name_columns</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">values</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Kemal Inecik.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>